<html>

	<script src="https://www.desmos.com/api/v1.8/calculator.js?apiKey=dcb31709b452b1cf9dc26972add0fda6"></script>

		
	<head>
		<style>
/*
			body {
				margin: auto;
				max-width: 600px;
			}*/

			#calculator {
				display: inline-block;
				margin: 30px;
			}
		</style>
	</head>


	<body>
		<center>
			<br>
			<h1>Polynuclear Growth Process</h1>
			<div id="calculator" style="width: 650px; height: 650px;"></div>
			<br>
			<button onclick="time_step()"><h1>Time Step</h1></button>
			<button onclick="reset_plot()"><h1>Reset</h1></button>
		</center>
	</body>

	<script>


		var elt = document.getElementById('calculator');
		var calculator = Desmos.GraphingCalculator(elt, {
			expressions:false,
			keypad:false,
			settingsMenu:false,
			zoomButtons:false,
			// lockViewport:true,
			showYAxis: false,
			showXAxis: false,
			xAxisStep: 1,
			xAxisMinorSubdivisions: 1,
			yAxisStep: 1,
			yAxisMinorSubdivisions: 1
		});




		class line {
			constructor() {
				this.left = [0];
				this.mid = 0;
				this.right = [0];
			}

			add_left(el) {
				this.set(this.left.length, el);
				this.left.push(0);
			}

			add_right(el) {
				this.set(this.right.length, el);
				this.right.push(0);
			}

			get(loc) {
				if (loc == 0) {
					return this.mid || 0;
				} else if (loc > 0) {
					return this.right[loc - 1] || 0;
				} else if (loc < 0) {
					return this.left[- 1 - loc] || 0;
				}
			}

			set(loc, el) {
				if (loc == 0) {
					this.mid = el;
				} else if (loc > 0) {
					this.right[loc - 1] = el;
				} else if (loc < 0) {
					this.left[-loc - 1] = el;
				}
			}

			indices = function *() {
				for (let i = -this.left.length; i < 0; i ++) {
					yield i;
				}
				yield 0;
				for (let i = 1; i <= this.right.length; i++) {
					yield i;
				}
			}

			to_list() {
				let ret = [];
				for (let i of this.indices()) {
					ret.push(this.get(i));
				}
				return ret;
			}

			points() {
				let ret = [];
				ret.push([-this.left.length - 1, 0])
				for (let i of this.indices()) {
					ret.push([i, this.get(i)]);
				}
			ret.push([this.right.length + 1, 0])
				return ret;
			}

			add(line) {
				for (let i of line.indices()) {
					this.set(i, this.get(i) + line.get(i))
				}
				return this;
			}

			grow() {
				let overlaps = new line;

				for (let i of this.indices()) {

					let L = this.get(i - 1);
					let C = this.get(i);
					let R = this.get(i + 1);
					
					let max = Math.max(L, C, R);
					let min = Math.min(L, C, R);

					this.set(i, max);
					if (min == C && C != 0) {
						overlaps.set(i, Math.abs(R - L));
					}
				}
				return overlaps;
			}

			is_zero() {
				for (let i of this.indices()) {
					if (this.get(i)) {
						return false;
					}
				}
				return true;
			}


		}


		// let a = new line();
		// a.set(0, 1);
		// plot_line(a);
		// a.grow();
		// plot_line(a);



		function list_to_line(arr) {
			let ret = new line;
			let m = arr.length - 1;
			let i = 0;
			for (let j = -m; j < 0; j+=2) {
				ret.set(j, arr[i]);
				i++
				ret.set(j + 1, 0);
			}
			let offset = 1;
			if (arr.length % 2 == 1) {
				ret.set(0, arr[i]);
				i++;
			} else {
				offset = 0;
				ret.set(0, 0);
			}
			for (let j = offset; j <= m; j+=2) {
				ret.set(j, 0);
				ret.set(j + 1, arr[i]);
				i++;
			}
			return ret;
		}

		function plot_line(line, shift) {
			shift = shift || 0;

			let id = 'line' + String(Math.random());

			let points = [['-\\infty', shift]];
			for (let p of line.points()) {
				points.push([p[0] - 1/2, (p[1] || 0) + shift]);
				points.push([p[0] + 1/2, (p[1] || 0) + shift]);
			}
			points.push(['\\infty', shift]);

			calculator.setExpression({
				id: id,
				latex: '[' + points.map(p => '(' + p[0] + ',' + p[1] + ')') + ']',
				lines: true,
				points: false,
				color: Desmos.Colors.BLUE,
				lineWidth: 3
			});

			return id;
		}



		
		
		var ids, show, curr;


		function reset_plot() {
			curr = 1;
			show = [new line];
			clear_plot();
			ids = [];
			update_plot();
		}

		function clear_plot() {
			while (ids && ids.length > 0) {
				calculator.removeExpression({id:ids.pop()});
			}
		}


		function time_step() {

			// grow each line
			let to_add = new line();
			for (let i = 0; i < show.length; i++) {
				let new_to_add = show[i].grow();
				show[i].add(to_add);
				to_add = new_to_add;
			}
			if (!to_add.is_zero()) {
				show.push(to_add)
			}

			// random growth on top line
			let r_arr = [];
			for (let i = 0; i < curr; i++) {
				r_arr.push(Math.random());
			}
			random_growth = list_to_line(r_arr);
			curr++;
			show[0].add(random_growth);
			update_plot();
		}





		function update_plot() {
			clear_plot();
			for (let i = 0; i < show.length; i++) {
				ids.push(plot_line(show[i], -i));
			}
		}


		reset_plot();


		// let test_line = list_to_line([1, 2, 3, 4, 5, 6, 7]);

		// plot_line(test_line, 10);

		// let bumps = test_line.grow();

		// plot_line(test_line);

		// plot_line(bumps);








	</script>
</html>







